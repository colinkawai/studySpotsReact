{"ast":null,"code":"let counter = 0;\nlet scriptMap = typeof window !== 'undefined' && window._scriptMap || new Map();\n\nconst window = require('./windowOrGlobal');\n\nexport const ScriptCache = function (global) {\n  global._scriptMap = global._scriptMap || scriptMap;\n  return function ScriptCache(scripts) {\n    const Cache = {};\n\n    Cache._onLoad = function (key) {\n      return cb => {\n        let registered = true;\n\n        function unregister() {\n          registered = false;\n        }\n\n        let stored = scriptMap.get(key);\n\n        if (stored) {\n          stored.promise.then(() => {\n            if (registered) {\n              stored.error ? cb(stored.error) : cb(null, stored);\n            }\n\n            return stored;\n          });\n        } else {// TODO:\n        }\n\n        return unregister;\n      };\n    };\n\n    Cache._scriptTag = (key, src) => {\n      if (!scriptMap.has(key)) {\n        // Server side rendering environments don't always have access to the `document` global.\n        // In these cases, we're not going to be able to return a script tag, so just return null.\n        if (typeof document === 'undefined') return null;\n        let tag = document.createElement('script');\n        let promise = new Promise((resolve, reject) => {\n          let resolved = false,\n              errored = false,\n              body = document.getElementsByTagName('body')[0];\n          tag.type = 'text/javascript';\n          tag.async = false; // Load in order\n\n          const cbName = `loaderCB${counter++}${Date.now()}`;\n          let cb;\n\n          let handleResult = state => {\n            return evt => {\n              let stored = scriptMap.get(key);\n\n              if (state === 'loaded') {\n                stored.resolved = true;\n                resolve(src); // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = []\n              } else if (state === 'error') {\n                stored.errored = true; // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = [];\n\n                reject(evt);\n              }\n\n              stored.loaded = true;\n              cleanup();\n            };\n          };\n\n          const cleanup = () => {\n            if (global[cbName] && typeof global[cbName] === 'function') {\n              global[cbName] = null;\n              delete global[cbName];\n            }\n          };\n\n          tag.onload = handleResult('loaded');\n          tag.onerror = handleResult('error');\n\n          tag.onreadystatechange = () => {\n            handleResult(tag.readyState);\n          }; // Pick off callback, if there is one\n\n\n          if (src.match(/callback=CALLBACK_NAME/)) {\n            src = src.replace(/(callback=)[^\\&]+/, `$1${cbName}`);\n            cb = window[cbName] = tag.onload;\n          } else {\n            tag.addEventListener('load', tag.onload);\n          }\n\n          tag.addEventListener('error', tag.onerror);\n          tag.src = src;\n          body.appendChild(tag);\n          return tag;\n        });\n        let initialState = {\n          loaded: false,\n          error: false,\n          promise: promise,\n          tag\n        };\n        scriptMap.set(key, initialState);\n      }\n\n      return scriptMap.get(key);\n    }; // let scriptTags = document.querySelectorAll('script')\n    //\n    // NodeList.prototype.filter = Array.prototype.filter;\n    // NodeList.prototype.map = Array.prototype.map;\n    // const initialScripts = scriptTags\n    //   .filter(s => !!s.src)\n    //   .map(s => s.src.split('?')[0])\n    //   .reduce((memo, script) => {\n    //     memo[script] = script;\n    //     return memo;\n    //   }, {});\n\n\n    Object.keys(scripts).forEach(function (key) {\n      const script = scripts[key];\n      const tag = window._scriptMap.has(key) ? window._scriptMap.get(key).tag : Cache._scriptTag(key, script);\n      Cache[key] = {\n        tag: tag,\n        onLoad: Cache._onLoad(key)\n      };\n    });\n    return Cache;\n  };\n}(window);\nexport default ScriptCache;","map":{"version":3,"sources":["/Users/colinkawai/mapreacdt/src/lib/ScriptCache.js"],"names":["counter","scriptMap","window","_scriptMap","Map","require","ScriptCache","global","scripts","Cache","_onLoad","key","cb","registered","unregister","stored","get","promise","then","error","_scriptTag","src","has","document","tag","createElement","Promise","resolve","reject","resolved","errored","body","getElementsByTagName","type","async","cbName","Date","now","handleResult","state","evt","loaded","cleanup","onload","onerror","onreadystatechange","readyState","match","replace","addEventListener","appendChild","initialState","set","Object","keys","forEach","script","onLoad"],"mappings":"AAAA,IAAIA,OAAO,GAAG,CAAd;AACA,IAAIC,SAAS,GAAG,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,UAAxC,IAAsD,IAAIC,GAAJ,EAAtE;;AACA,MAAMF,MAAM,GAAGG,OAAO,CAAC,kBAAD,CAAtB;;AAEA,OAAO,MAAMC,WAAW,GAAI,UAASC,MAAT,EAAiB;AACzCA,EAAAA,MAAM,CAACJ,UAAP,GAAoBI,MAAM,CAACJ,UAAP,IAAqBF,SAAzC;AACA,SAAO,SAASK,WAAT,CAAqBE,OAArB,EAA8B;AACjC,UAAMC,KAAK,GAAG,EAAd;;AAEAA,IAAAA,KAAK,CAACC,OAAN,GAAgB,UAASC,GAAT,EAAc;AAC1B,aAAQC,EAAD,IAAQ;AACX,YAAIC,UAAU,GAAG,IAAjB;;AAEA,iBAASC,UAAT,GAAsB;AAClBD,UAAAA,UAAU,GAAG,KAAb;AACH;;AAED,YAAIE,MAAM,GAAGd,SAAS,CAACe,GAAV,CAAcL,GAAd,CAAb;;AAEA,YAAII,MAAJ,EAAY;AACRA,UAAAA,MAAM,CAACE,OAAP,CAAeC,IAAf,CAAoB,MAAM;AACtB,gBAAIL,UAAJ,EAAgB;AACdE,cAAAA,MAAM,CAACI,KAAP,GAAeP,EAAE,CAACG,MAAM,CAACI,KAAR,CAAjB,GAAkCP,EAAE,CAAC,IAAD,EAAOG,MAAP,CAApC;AACD;;AAED,mBAAOA,MAAP;AACH,WAND;AAOH,SARD,MAQO,CACH;AACH;;AAED,eAAOD,UAAP;AACH,OAtBD;AAuBH,KAxBD;;AA0BAL,IAAAA,KAAK,CAACW,UAAN,GAAmB,CAACT,GAAD,EAAMU,GAAN,KAAc;AAC7B,UAAI,CAACpB,SAAS,CAACqB,GAAV,CAAcX,GAAd,CAAL,EAAyB;AACrB;AACA;AACA,YAAI,OAAOY,QAAP,KAAoB,WAAxB,EAAqC,OAAO,IAAP;AAErC,YAAIC,GAAG,GAAGD,QAAQ,CAACE,aAAT,CAAuB,QAAvB,CAAV;AACA,YAAIR,OAAO,GAAG,IAAIS,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC3C,cAAIC,QAAQ,GAAG,KAAf;AAAA,cACIC,OAAO,GAAG,KADd;AAAA,cAEIC,IAAI,GAAGR,QAAQ,CAACS,oBAAT,CAA8B,MAA9B,EAAsC,CAAtC,CAFX;AAIAR,UAAAA,GAAG,CAACS,IAAJ,GAAW,iBAAX;AACAT,UAAAA,GAAG,CAACU,KAAJ,GAAY,KAAZ,CAN2C,CAMxB;;AAEnB,gBAAMC,MAAM,GAAI,WAAUnC,OAAO,EAAG,GAAEoC,IAAI,CAACC,GAAL,EAAW,EAAjD;AACA,cAAIzB,EAAJ;;AAEA,cAAI0B,YAAY,GAAIC,KAAD,IAAW;AAC1B,mBAAQC,GAAD,IAAS;AACZ,kBAAIzB,MAAM,GAAGd,SAAS,CAACe,GAAV,CAAcL,GAAd,CAAb;;AACA,kBAAI4B,KAAK,KAAK,QAAd,EAAwB;AACpBxB,gBAAAA,MAAM,CAACc,QAAP,GAAkB,IAAlB;AACAF,gBAAAA,OAAO,CAACN,GAAD,CAAP,CAFoB,CAGpB;AACA;AACH,eALD,MAKO,IAAIkB,KAAK,KAAK,OAAd,EAAuB;AAC1BxB,gBAAAA,MAAM,CAACe,OAAP,GAAiB,IAAjB,CAD0B,CAE1B;AACA;;AACAF,gBAAAA,MAAM,CAACY,GAAD,CAAN;AACH;;AACDzB,cAAAA,MAAM,CAAC0B,MAAP,GAAgB,IAAhB;AAEAC,cAAAA,OAAO;AACV,aAhBD;AAiBH,WAlBD;;AAoBA,gBAAMA,OAAO,GAAG,MAAM;AAClB,gBAAInC,MAAM,CAAC4B,MAAD,CAAN,IAAkB,OAAO5B,MAAM,CAAC4B,MAAD,CAAb,KAA0B,UAAhD,EAA4D;AACxD5B,cAAAA,MAAM,CAAC4B,MAAD,CAAN,GAAiB,IAAjB;AACA,qBAAO5B,MAAM,CAAC4B,MAAD,CAAb;AACH;AACJ,WALD;;AAOAX,UAAAA,GAAG,CAACmB,MAAJ,GAAaL,YAAY,CAAC,QAAD,CAAzB;AACAd,UAAAA,GAAG,CAACoB,OAAJ,GAAcN,YAAY,CAAC,OAAD,CAA1B;;AACAd,UAAAA,GAAG,CAACqB,kBAAJ,GAAyB,MAAM;AAC3BP,YAAAA,YAAY,CAACd,GAAG,CAACsB,UAAL,CAAZ;AACH,WAFD,CAxC2C,CA4C3C;;;AACA,cAAIzB,GAAG,CAAC0B,KAAJ,CAAU,wBAAV,CAAJ,EAAyC;AACrC1B,YAAAA,GAAG,GAAGA,GAAG,CAAC2B,OAAJ,CAAY,mBAAZ,EAAkC,KAAIb,MAAO,EAA7C,CAAN;AACAvB,YAAAA,EAAE,GAAGV,MAAM,CAACiC,MAAD,CAAN,GAAiBX,GAAG,CAACmB,MAA1B;AACH,WAHD,MAGO;AACHnB,YAAAA,GAAG,CAACyB,gBAAJ,CAAqB,MAArB,EAA6BzB,GAAG,CAACmB,MAAjC;AACH;;AACDnB,UAAAA,GAAG,CAACyB,gBAAJ,CAAqB,OAArB,EAA8BzB,GAAG,CAACoB,OAAlC;AAEApB,UAAAA,GAAG,CAACH,GAAJ,GAAUA,GAAV;AACAU,UAAAA,IAAI,CAACmB,WAAL,CAAiB1B,GAAjB;AAEA,iBAAOA,GAAP;AACH,SAzDa,CAAd;AA0DA,YAAI2B,YAAY,GAAG;AACfV,UAAAA,MAAM,EAAE,KADO;AAEftB,UAAAA,KAAK,EAAE,KAFQ;AAGfF,UAAAA,OAAO,EAAEA,OAHM;AAIfO,UAAAA;AAJe,SAAnB;AAMAvB,QAAAA,SAAS,CAACmD,GAAV,CAAczC,GAAd,EAAmBwC,YAAnB;AACH;;AACD,aAAOlD,SAAS,CAACe,GAAV,CAAcL,GAAd,CAAP;AACH,KA1ED,CA7BiC,CAyGjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA0C,IAAAA,MAAM,CAACC,IAAP,CAAY9C,OAAZ,EAAqB+C,OAArB,CAA6B,UAAS5C,GAAT,EAAc;AACvC,YAAM6C,MAAM,GAAGhD,OAAO,CAACG,GAAD,CAAtB;AAEA,YAAMa,GAAG,GAAGtB,MAAM,CAACC,UAAP,CAAkBmB,GAAlB,CAAsBX,GAAtB,IACAT,MAAM,CAACC,UAAP,CAAkBa,GAAlB,CAAsBL,GAAtB,EAA2Ba,GAD3B,GAEAf,KAAK,CAACW,UAAN,CAAiBT,GAAjB,EAAsB6C,MAAtB,CAFZ;AAIA/C,MAAAA,KAAK,CAACE,GAAD,CAAL,GAAa;AACTa,QAAAA,GAAG,EAAEA,GADI;AAETiC,QAAAA,MAAM,EAAEhD,KAAK,CAACC,OAAN,CAAcC,GAAd;AAFC,OAAb;AAIH,KAXD;AAaA,WAAOF,KAAP;AACH,GAnID;AAoIH,CAtI0B,CAsIxBP,MAtIwB,CAApB;AAwIP,eAAeI,WAAf","sourcesContent":["let counter = 0;\nlet scriptMap = typeof window !== 'undefined' && window._scriptMap || new Map();\nconst window = require('./windowOrGlobal');\n\nexport const ScriptCache = (function(global) {\n    global._scriptMap = global._scriptMap || scriptMap;\n    return function ScriptCache(scripts) {\n        const Cache = {}\n\n        Cache._onLoad = function(key) {\n            return (cb) => {\n                let registered = true;\n\n                function unregister() {\n                    registered = false;\n                }\n\n                let stored = scriptMap.get(key);\n\n                if (stored) {\n                    stored.promise.then(() => {\n                        if (registered) {\n                          stored.error ? cb(stored.error) : cb(null, stored)\n                        }\n\n                        return stored;\n                    });\n                } else {\n                    // TODO:\n                }\n\n                return unregister;\n            }\n        }\n\n        Cache._scriptTag = (key, src) => {\n            if (!scriptMap.has(key)) {\n                // Server side rendering environments don't always have access to the `document` global.\n                // In these cases, we're not going to be able to return a script tag, so just return null.\n                if (typeof document === 'undefined') return null;\n\n                let tag = document.createElement('script');\n                let promise = new Promise((resolve, reject) => {\n                    let resolved = false,\n                        errored = false,\n                        body = document.getElementsByTagName('body')[0];\n\n                    tag.type = 'text/javascript';\n                    tag.async = false; // Load in order\n\n                    const cbName = `loaderCB${counter++}${Date.now()}`;\n                    let cb;\n\n                    let handleResult = (state) => {\n                        return (evt) => {\n                            let stored = scriptMap.get(key);\n                            if (state === 'loaded') {\n                                stored.resolved = true;\n                                resolve(src);\n                                // stored.handlers.forEach(h => h.call(null, stored))\n                                // stored.handlers = []\n                            } else if (state === 'error') {\n                                stored.errored = true;\n                                // stored.handlers.forEach(h => h.call(null, stored))\n                                // stored.handlers = [];\n                                reject(evt)\n                            }\n                            stored.loaded = true;\n\n                            cleanup();\n                        }\n                    }\n\n                    const cleanup = () => {\n                        if (global[cbName] && typeof global[cbName] === 'function') {\n                            global[cbName] = null;\n                            delete global[cbName]\n                        }\n                    }\n\n                    tag.onload = handleResult('loaded');\n                    tag.onerror = handleResult('error')\n                    tag.onreadystatechange = () => {\n                        handleResult(tag.readyState)\n                    }\n\n                    // Pick off callback, if there is one\n                    if (src.match(/callback=CALLBACK_NAME/)) {\n                        src = src.replace(/(callback=)[^\\&]+/, `$1${cbName}`)\n                        cb = window[cbName] = tag.onload;\n                    } else {\n                        tag.addEventListener('load', tag.onload)\n                    }\n                    tag.addEventListener('error', tag.onerror);\n\n                    tag.src = src;\n                    body.appendChild(tag);\n\n                    return tag;\n                });\n                let initialState = {\n                    loaded: false,\n                    error: false,\n                    promise: promise,\n                    tag\n                }\n                scriptMap.set(key, initialState);\n            }\n            return scriptMap.get(key);\n        }\n\n        // let scriptTags = document.querySelectorAll('script')\n        //\n        // NodeList.prototype.filter = Array.prototype.filter;\n        // NodeList.prototype.map = Array.prototype.map;\n        // const initialScripts = scriptTags\n        //   .filter(s => !!s.src)\n        //   .map(s => s.src.split('?')[0])\n        //   .reduce((memo, script) => {\n        //     memo[script] = script;\n        //     return memo;\n        //   }, {});\n\n        Object.keys(scripts).forEach(function(key) {\n            const script = scripts[key];\n\n            const tag = window._scriptMap.has(key) ?\n                        window._scriptMap.get(key).tag :\n                        Cache._scriptTag(key, script);\n\n            Cache[key] = {\n                tag: tag,\n                onLoad: Cache._onLoad(key),\n            }\n        })\n\n        return Cache;\n    }\n})(window);\n\nexport default ScriptCache;\n"]},"metadata":{},"sourceType":"module"}