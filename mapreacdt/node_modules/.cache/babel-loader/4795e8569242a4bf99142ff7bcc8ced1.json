{"ast":null,"code":"let counter = 0;\n\nconst window = require(\"./windowOrGlobal\");\n\nlet scriptMap = typeof window !== \"undefined\" && window._scriptMap || new Map();\nexport const ScriptCache = function (global) {\n  global._scriptMap = global._scriptMap || scriptMap;\n  return function ScriptCache(scripts) {\n    const Cache = {};\n\n    Cache._onLoad = function (key) {\n      return cb => {\n        let registered = true;\n\n        function unregister() {\n          registered = false;\n        }\n\n        let stored = scriptMap.get(key);\n\n        if (stored) {\n          stored.promise.then(() => {\n            if (registered) {\n              stored.error ? cb(stored.error) : cb(null, stored);\n            }\n\n            return stored;\n          });\n        } else {// TODO:\n        }\n\n        return unregister;\n      };\n    };\n\n    Cache._scriptTag = (key, src) => {\n      if (!scriptMap.has(key)) {\n        // Server side rendering environments don't always have access to the `document` global.\n        // In these cases, we're not going to be able to return a script tag, so just return null.\n        if (typeof document === \"undefined\") return null;\n        let tag = document.createElement(\"script\");\n        let promise = new Promise((resolve, reject) => {\n          let resolved = false,\n              errored = false,\n              body = document.getElementsByTagName(\"body\")[0];\n          tag.type = \"text/javascript\";\n          tag.async = false; // Load in order\n\n          const cbName = `loaderCB${counter++}${Date.now()}`;\n          let cb;\n\n          let handleResult = state => {\n            return evt => {\n              let stored = scriptMap.get(key);\n\n              if (state === \"loaded\") {\n                stored.resolved = true;\n                resolve(src); // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = []\n              } else if (state === \"error\") {\n                stored.errored = true; // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = [];\n\n                reject(evt);\n              }\n\n              stored.loaded = true;\n              cleanup();\n            };\n          };\n\n          const cleanup = () => {\n            if (global[cbName] && typeof global[cbName] === \"function\") {\n              global[cbName] = null;\n              delete global[cbName];\n            }\n          };\n\n          tag.onload = handleResult(\"loaded\");\n          tag.onerror = handleResult(\"error\");\n\n          tag.onreadystatechange = () => {\n            handleResult(tag.readyState);\n          }; // Pick off callback, if there is one\n\n\n          if (src.match(/callback=CALLBACK_NAME/)) {\n            src = src.replace(/(callback=)[^\\&]+/, `$1${cbName}`);\n            cb = window[cbName] = tag.onload;\n          } else {\n            tag.addEventListener(\"load\", tag.onload);\n          }\n\n          tag.addEventListener(\"error\", tag.onerror);\n          tag.src = src;\n          body.appendChild(tag);\n          return tag;\n        });\n        let initialState = {\n          loaded: false,\n          error: false,\n          promise: promise,\n          tag\n        };\n        scriptMap.set(key, initialState);\n      }\n\n      return scriptMap.get(key);\n    }; // let scriptTags = document.querySelectorAll('script')\n    //\n    // NodeList.prototype.filter = Array.prototype.filter;\n    // NodeList.prototype.map = Array.prototype.map;\n    // const initialScripts = scriptTags\n    //   .filter(s => !!s.src)\n    //   .map(s => s.src.split('?')[0])\n    //   .reduce((memo, script) => {\n    //     memo[script] = script;\n    //     return memo;\n    //   }, {});\n\n\n    Object.keys(scripts).forEach(function (key) {\n      const script = scripts[key];\n      const tag = window._scriptMap.has(key) ? window._scriptMap.get(key).tag : Cache._scriptTag(key, script);\n      Cache[key] = {\n        tag: tag,\n        onLoad: Cache._onLoad(key)\n      };\n    });\n    return Cache;\n  };\n}(window);\nexport default ScriptCache;","map":{"version":3,"sources":["/Users/colinkawai/studySpotsReact/mapreacdt/src/lib/ScriptCache.js"],"names":["counter","window","require","scriptMap","_scriptMap","Map","ScriptCache","global","scripts","Cache","_onLoad","key","cb","registered","unregister","stored","get","promise","then","error","_scriptTag","src","has","document","tag","createElement","Promise","resolve","reject","resolved","errored","body","getElementsByTagName","type","async","cbName","Date","now","handleResult","state","evt","loaded","cleanup","onload","onerror","onreadystatechange","readyState","match","replace","addEventListener","appendChild","initialState","set","Object","keys","forEach","script","onLoad"],"mappings":"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","sourcesContent":["let counter = 0;\nconst window = require(\"./windowOrGlobal\");\nlet scriptMap =\n  (typeof window !== \"undefined\" && window._scriptMap) || new Map();\n\nexport const ScriptCache = (function(global) {\n  global._scriptMap = global._scriptMap || scriptMap;\n  return function ScriptCache(scripts) {\n    const Cache = {};\n\n    Cache._onLoad = function(key) {\n      return cb => {\n        let registered = true;\n\n        function unregister() {\n          registered = false;\n        }\n\n        let stored = scriptMap.get(key);\n\n        if (stored) {\n          stored.promise.then(() => {\n            if (registered) {\n              stored.error ? cb(stored.error) : cb(null, stored);\n            }\n\n            return stored;\n          });\n        } else {\n          // TODO:\n        }\n\n        return unregister;\n      };\n    };\n\n    Cache._scriptTag = (key, src) => {\n      if (!scriptMap.has(key)) {\n        // Server side rendering environments don't always have access to the `document` global.\n        // In these cases, we're not going to be able to return a script tag, so just return null.\n        if (typeof document === \"undefined\") return null;\n\n        let tag = document.createElement(\"script\");\n        let promise = new Promise((resolve, reject) => {\n          let resolved = false,\n            errored = false,\n            body = document.getElementsByTagName(\"body\")[0];\n\n          tag.type = \"text/javascript\";\n          tag.async = false; // Load in order\n\n          const cbName = `loaderCB${counter++}${Date.now()}`;\n          let cb;\n\n          let handleResult = state => {\n            return evt => {\n              let stored = scriptMap.get(key);\n              if (state === \"loaded\") {\n                stored.resolved = true;\n                resolve(src);\n                // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = []\n              } else if (state === \"error\") {\n                stored.errored = true;\n                // stored.handlers.forEach(h => h.call(null, stored))\n                // stored.handlers = [];\n                reject(evt);\n              }\n              stored.loaded = true;\n\n              cleanup();\n            };\n          };\n\n          const cleanup = () => {\n            if (global[cbName] && typeof global[cbName] === \"function\") {\n              global[cbName] = null;\n              delete global[cbName];\n            }\n          };\n\n          tag.onload = handleResult(\"loaded\");\n          tag.onerror = handleResult(\"error\");\n          tag.onreadystatechange = () => {\n            handleResult(tag.readyState);\n          };\n\n          // Pick off callback, if there is one\n          if (src.match(/callback=CALLBACK_NAME/)) {\n            src = src.replace(/(callback=)[^\\&]+/, `$1${cbName}`);\n            cb = window[cbName] = tag.onload;\n          } else {\n            tag.addEventListener(\"load\", tag.onload);\n          }\n          tag.addEventListener(\"error\", tag.onerror);\n\n          tag.src = src;\n          body.appendChild(tag);\n\n          return tag;\n        });\n        let initialState = {\n          loaded: false,\n          error: false,\n          promise: promise,\n          tag\n        };\n        scriptMap.set(key, initialState);\n      }\n      return scriptMap.get(key);\n    };\n\n    // let scriptTags = document.querySelectorAll('script')\n    //\n    // NodeList.prototype.filter = Array.prototype.filter;\n    // NodeList.prototype.map = Array.prototype.map;\n    // const initialScripts = scriptTags\n    //   .filter(s => !!s.src)\n    //   .map(s => s.src.split('?')[0])\n    //   .reduce((memo, script) => {\n    //     memo[script] = script;\n    //     return memo;\n    //   }, {});\n\n    Object.keys(scripts).forEach(function(key) {\n      const script = scripts[key];\n\n      const tag = window._scriptMap.has(key)\n        ? window._scriptMap.get(key).tag\n        : Cache._scriptTag(key, script);\n\n      Cache[key] = {\n        tag: tag,\n        onLoad: Cache._onLoad(key)\n      };\n    });\n\n    return Cache;\n  };\n})(window);\n\nexport default ScriptCache;\n"]},"metadata":{},"sourceType":"module"}